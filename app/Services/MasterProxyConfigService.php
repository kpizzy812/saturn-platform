<?php

namespace App\Services;

use App\Models\Application;
use App\Models\Server;
use Symfony\Component\Yaml\Yaml;

/**
 * Manages master Traefik's file-based dynamic config for remote applications.
 *
 * When an app is deployed on a remote server, this service generates a YAML
 * config file on the master server so Traefik routes traffic to the remote.
 * Traefik watches the dynamic config directory with providers.file.watch=true.
 */
class MasterProxyConfigService
{
    /**
     * Sync a remote route for an application on the master Traefik.
     * If the app is on the master server itself, remove any stale file config.
     */
    public function syncRemoteRoute(Application $app): void
    {
        $masterServer = Server::masterServer();
        if (! $masterServer) {
            return;
        }

        $appServer = $app->destination?->server;
        if (! $appServer) {
            return;
        }

        // If app is on the master server, no remote route needed
        if ($appServer->isMasterServer()) {
            $this->removeRemoteRoute($app);

            return;
        }

        $fqdns = $this->parseFqdns($app->fqdn);
        if (empty($fqdns)) {
            return;
        }

        $config = $this->buildRouteConfig($app, $appServer, $fqdns);
        $yaml = Yaml::dump($config, 12, 2);

        $banner = "# Auto-generated by Saturn Platform for remote app routing.\n"
            ."# App: {$app->name} (UUID: {$app->uuid})\n"
            ."# Remote server: {$appServer->name} ({$appServer->ip})\n\n";

        $content = $banner.$yaml;
        $dynamicPath = $this->getDynamicConfigPath($masterServer);
        $fileName = "remote-{$app->uuid}.yaml";
        $filePath = "{$dynamicPath}/{$fileName}";

        $base64 = base64_encode($content);
        instant_remote_process([
            "mkdir -p {$dynamicPath}",
            "echo '{$base64}' | base64 -d | tee {$filePath} > /dev/null",
        ], $masterServer);
    }

    /**
     * Remove the remote route config file for an application.
     */
    public function removeRemoteRoute(Application $app): void
    {
        $masterServer = Server::masterServer();
        if (! $masterServer) {
            return;
        }

        $dynamicPath = $this->getDynamicConfigPath($masterServer);
        $fileName = "remote-{$app->uuid}.yaml";
        $filePath = "{$dynamicPath}/{$fileName}";

        instant_remote_process([
            "rm -f {$filePath}",
        ], $masterServer);
    }

    /**
     * Full reconciliation: sync all remote routes.
     */
    public function syncAllRemoteRoutes(): void
    {
        $masterServer = Server::masterServer();
        if (! $masterServer) {
            return;
        }

        // Get all applications across all servers
        $applications = Application::all();

        foreach ($applications as $app) {
            $appServer = $app->destination?->server;
            if (! $appServer) {
                continue;
            }

            if ($appServer->isMasterServer()) {
                // Clean up any stale remote configs for master-server apps
                $this->removeRemoteRoute($app);

                continue;
            }

            if (! $appServer->isFunctional()) {
                continue;
            }

            $this->syncRemoteRoute($app);
        }
    }

    /**
     * Build the Traefik dynamic configuration for a remote app.
     */
    private function buildRouteConfig(Application $app, Server $remoteServer, array $fqdns): array
    {
        $uuid = $app->uuid;
        $remoteIp = $remoteServer->ip;
        $port = $this->getAppPort($app);

        $routers = [];
        $services = [];

        // Service: points to remote server's HTTP entrypoint
        $serviceName = "remote-{$uuid}";
        $services[$serviceName] = [
            'loadBalancer' => [
                'servers' => [
                    ['url' => "http://{$remoteIp}:{$port}"],
                ],
            ],
        ];

        foreach ($fqdns as $index => $fqdn) {
            $routerName = "remote-{$uuid}".($index > 0 ? "-{$index}" : '');

            $host = parse_url($fqdn, PHP_URL_HOST) ?: $fqdn;
            $scheme = parse_url($fqdn, PHP_URL_SCHEME) ?: 'http';

            // HTTP router
            $routers["{$routerName}-http"] = [
                'entryPoints' => ['http'],
                'service' => $serviceName,
                'rule' => "Host(`{$host}`)",
            ];

            // HTTPS router with cert resolver
            if ($scheme === 'https') {
                $routers["{$routerName}-https"] = [
                    'entryPoints' => ['https'],
                    'service' => $serviceName,
                    'rule' => "Host(`{$host}`)",
                    'tls' => [
                        'certResolver' => 'letsencrypt',
                    ],
                ];

                // Add redirect middleware for HTTP -> HTTPS
                $routers["{$routerName}-http"]['middlewares'] = ["redirect-to-https-{$uuid}"];
            }
        }

        $config = [
            'http' => [
                'routers' => $routers,
                'services' => $services,
            ],
        ];

        // Add redirect middleware if any HTTPS domains
        $hasHttps = collect($fqdns)->contains(fn ($f) => str_starts_with($f, 'https://'));
        if ($hasHttps) {
            $config['http']['middlewares'] = [
                "redirect-to-https-{$uuid}" => [
                    'redirectScheme' => [
                        'scheme' => 'https',
                    ],
                ],
            ];
        }

        return $config;
    }

    /**
     * Parse FQDN string (comma-separated) into array.
     */
    private function parseFqdns(?string $fqdn): array
    {
        if (empty($fqdn)) {
            return [];
        }

        return collect(explode(',', $fqdn))
            ->map(fn ($f) => trim($f))
            ->filter()
            ->values()
            ->toArray();
    }

    /**
     * Get the exposed port for the application (default 80).
     */
    private function getAppPort(Application $app): int
    {
        $ports = $app->ports_exposes;
        if (empty($ports)) {
            return 80;
        }

        // Take the first exposed port
        $firstPort = explode(',', $ports)[0];

        return (int) trim($firstPort) ?: 80;
    }

    /**
     * Get the dynamic config path on the master server.
     */
    private function getDynamicConfigPath(Server $masterServer): string
    {
        $proxyPath = $masterServer->proxyPath();

        return "{$proxyPath}/dynamic";
    }
}
