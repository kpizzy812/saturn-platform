<?php

use App\Models\Server;

beforeEach(function () {
    // Mock Log to prevent actual logging
    Illuminate\Support\Facades\Log::shouldReceive('error')->andReturn(null);
    Illuminate\Support\Facades\Log::shouldReceive('info')->andReturn(null);
});

it('generateUrl produces correct URL with wildcard domain', function () {
    // Create a settings object with the wildcard domain property
    $serverSettings = new stdClass;
    $serverSettings->wildcard_domain = 'http://example.com';

    $server = Mockery::mock(Server::class)->makePartial()->shouldIgnoreMissing();
    $server->shouldReceive('getAttribute')
        ->with('settings')
        ->andReturn($serverSettings);
    // Also support object property access
    $server->settings = $serverSettings;

    // Test data_get with the mock
    $wildcard = data_get($server, 'settings.wildcard_domain');

    expect($wildcard)->toBe('http://example.com');

    // Test the URL generation logic manually (simulating generateUrl behavior)
    $random = 'abc123-def456';
    $url = Spatie\Url\Url::fromString($wildcard);
    $host = $url->getHost();
    $scheme = $url->getScheme();

    $generatedUrl = "$scheme://{$random}.$host";

    expect($generatedUrl)->toBe('http://abc123-def456.example.com');
});

it('generateUrl falls back to sslip when no wildcard domain', function () {
    // Test the sslip fallback logic for IPv4
    $ip = '192.168.1.100';
    $fallbackDomain = "http://{$ip}.sslip.io";

    $random = 'test-uuid';
    $url = Spatie\Url\Url::fromString($fallbackDomain);
    $host = $url->getHost();
    $scheme = $url->getScheme();

    $generatedUrl = "$scheme://{$random}.$host";

    expect($generatedUrl)->toBe('http://test-uuid.192.168.1.100.sslip.io');
});

it('autogenerate_domain defaults to true', function () {
    // Create a mock request
    $request = new Illuminate\Http\Request;

    // When autogenerate_domain is not set, boolean() should return the default (true)
    $autogenerateDomain = $request->boolean('autogenerate_domain', true);

    expect($autogenerateDomain)->toBeTrue();
});

it('autogenerate_domain can be set to false', function () {
    // Create a request with autogenerate_domain set to false
    $request = new Illuminate\Http\Request(['autogenerate_domain' => false]);

    $autogenerateDomain = $request->boolean('autogenerate_domain', true);

    expect($autogenerateDomain)->toBeFalse();
});

it('autogenerate_domain can be set to true explicitly', function () {
    // Create a request with autogenerate_domain set to true
    $request = new Illuminate\Http\Request(['autogenerate_domain' => true]);

    $autogenerateDomain = $request->boolean('autogenerate_domain', true);

    expect($autogenerateDomain)->toBeTrue();
});

it('domain is not auto-generated when domains field is provided', function () {
    // Test the logic: if domains is set, autogenerate should be skipped
    $fqdn = 'https://myapp.example.com';
    $autogenerateDomain = true;

    // The condition: $autogenerateDomain && blank($fqdn)
    $shouldAutogenerate = $autogenerateDomain && blank($fqdn);

    expect($shouldAutogenerate)->toBeFalse();
});

it('domain is auto-generated when domains field is empty and autogenerate is true', function () {
    // Test the logic: if domains is empty and autogenerate is true, should generate
    $fqdn = null;
    $autogenerateDomain = true;

    // The condition: $autogenerateDomain && blank($fqdn)
    $shouldAutogenerate = $autogenerateDomain && blank($fqdn);

    expect($shouldAutogenerate)->toBeTrue();

    // Also test with empty string
    $fqdn = '';
    $shouldAutogenerate = $autogenerateDomain && blank($fqdn);

    expect($shouldAutogenerate)->toBeTrue();
});

it('domain is not auto-generated when autogenerate is false', function () {
    // Test the logic: if autogenerate is false, should not generate even if domains is empty
    $fqdn = null;
    $autogenerateDomain = false;

    // The condition: $autogenerateDomain && blank($fqdn)
    $shouldAutogenerate = $autogenerateDomain && blank($fqdn);

    expect($shouldAutogenerate)->toBeFalse();
});

it('generateSubdomainFromName converts app name to DNS-safe slug', function () {
    // Test the slug generation logic (same as Str::slug which generateSubdomainFromName uses)
    expect(\Illuminate\Support\Str::slug('PixelPets'))->toBe('pixelpets');
    expect(\Illuminate\Support\Str::slug('My Cool App'))->toBe('my-cool-app');
    expect(\Illuminate\Support\Str::slug('hello_world 123'))->toBe('hello-world-123');
    expect(\Illuminate\Support\Str::slug('  Spaces  Around  '))->toBe('spaces-around');
    expect(\Illuminate\Support\Str::slug('UPPERCASE'))->toBe('uppercase');
    expect(\Illuminate\Support\Str::slug('app-with-dashes'))->toBe('app-with-dashes');
});

it('generateSubdomainFromName falls back for empty slug', function () {
    // Names that produce empty slugs should get a random fallback
    $emptySlug = \Illuminate\Support\Str::slug('!!!');
    expect($emptySlug)->toBe('');

    $emptySlug2 = \Illuminate\Support\Str::slug('');
    expect($emptySlug2)->toBe('');

    // The function uses Str::random(8) as fallback, which is always 8 chars
    $fallback = \Illuminate\Support\Str::random(8);
    expect(strlen($fallback))->toBe(8);
});

it('generateSubdomainFromName truncates long names', function () {
    $longName = str_repeat('a', 100);
    $slug = \Illuminate\Support\Str::slug($longName);
    $truncated = \Illuminate\Support\Str::limit($slug, 50, '');

    expect(strlen($truncated))->toBe(50);
});

it('generateUrl uses name-based slug instead of UUID', function () {
    // Simulate what now happens: name → slug → URL
    $appName = 'PixelPets';
    $slug = \Illuminate\Support\Str::slug($appName);

    $wildcard = 'https://saturn.ac';
    $url = Spatie\Url\Url::fromString($wildcard);
    $host = $url->getHost();
    $scheme = $url->getScheme();

    $generatedUrl = "$scheme://{$slug}.$host";
    expect($generatedUrl)->toBe('https://pixelpets.saturn.ac');
});

it('removeUnnecessaryFieldsFromRequest removes autogenerate_domain', function () {
    $request = new Illuminate\Http\Request([
        'autogenerate_domain' => true,
        'name' => 'test-app',
        'project_uuid' => 'abc123',
    ]);

    // Simulate removeUnnecessaryFieldsFromRequest
    $request->offsetUnset('autogenerate_domain');

    expect($request->has('autogenerate_domain'))->toBeFalse();
    expect($request->has('name'))->toBeTrue();
});
